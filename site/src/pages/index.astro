---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { WHATS_NEW } from "../lib/whatsNew";
import { geoEquirectangular, geoPath } from "d3-geo";
import { feature } from "topojson-client";
import landTopo from "world-atlas/land-110m.json";

const entries = await getCollection("languages");
function englishSortKey(title: string): string {
  const t = (title || "").trim();
  // Prefer any Latin/ASCII-ish segment (usually the English name) for grouping/sorting.
  const m = t.match(/[A-Za-z][A-Za-z0-9 .,'’()-]{1,}/);
  return (m?.[0] || t).trim().toLowerCase();
}

function normText(s: unknown): string {
  return String(s || "").trim().toLowerCase();
}

function regionTokens(r?: string | string[]) {
  const arr = Array.isArray(r) ? r : r ? [r] : [];
  return arr.map((x) => String(x));
}

const languages = entries
  .filter((e) => e.slug !== "lexicityall-languages" && e.data.title !== "Lexicity/All Languages")
  .map((e) => ({
    title: e.data.title,
    slug: e.slug,
    sortKey: englishSortKey(e.data.title),
    family: e.data.family || "",
    branch: e.data.branch || "",
    region: regionTokens(e.data.region),
    regionGroup: regionTokens(e.data.regionGroup),
    tags: e.data.tags || [],
    blurb: e.data.blurb || "",
    period: e.data.period,
    geo: e.data.geo
  }))
  .sort((a, b) => a.sortKey.localeCompare(b.sortKey) || a.title.localeCompare(b.title));

// Featured language rotates client-side (static deploys won’t rebuild daily).
const featuredPool = languages.filter((l) => (l.blurb || "").trim());
const pool = featuredPool.length ? featuredPool : languages;
const featuredItems = pool.map((l) => ({
  title: l.title,
  slug: l.slug,
  blurb: l.blurb,
  family: l.family,
  branch: l.branch,
  geo: l.geo
}));
const featuredJson = JSON.stringify(featuredItems).replace(/</g, "\\u003c");

// World silhouette path is build-time only; markers update client-side.
const FEATURE_W = 360;
const FEATURE_H = 180;
const scale = FEATURE_W / (2 * Math.PI);
const projection = geoEquirectangular().scale(scale).translate([FEATURE_W / 2, FEATURE_H / 2]);
const pathGen = geoPath(projection);
const landFeature = feature(landTopo as any, (landTopo as any).objects.land) as any;
const landPath = (pathGen(landFeature) as string) || "";

function clamp(n: number, lo: number, hi: number) {
  return Math.max(lo, Math.min(hi, n));
}
function normLon(lon: number) {
  return ((lon + 180) % 360 + 360) % 360 - 180;
}
function proj(lat: number, lon: number) {
  const clat = clamp(lat, -85, 85);
  const clon = normLon(lon);
  const p = projection([clon, clat]);
  return { x: p?.[0] ?? 0, y: p?.[1] ?? 0, clat, clon };
}
function kmToLatDeg(km: number) {
  return km / 111;
}
function kmToLonDegAtLat(km: number, lat: number) {
  const r = (Math.PI / 180) * lat;
  const denom = 111 * Math.max(0.2, Math.cos(r));
  return km / denom;
}

const initialGeo = featuredItems[0]?.geo;
let initialDot: { cx: number; cy: number } | null = null;
let initialEllipse: { cx: number; cy: number; rx: number; ry: number } | null = null;
let initialRect: { x: number; y: number; w: number; h: number } | null = null;

if (initialGeo?.center) {
  const p = proj(initialGeo.center.lat, initialGeo.center.lon);
  initialDot = { cx: p.x, cy: p.y };
  const km = initialGeo.radiusKm ?? 0;
  if (km > 0) {
    const ry = kmToLatDeg(km);
    const rx = kmToLonDegAtLat(km, p.clat);
    const px1 = proj(p.clat + ry, p.clon);
    const px2 = proj(p.clat, p.clon + rx);
    initialEllipse = { cx: p.x, cy: p.y, rx: Math.abs(px2.x - p.x), ry: Math.abs(px1.y - p.y) };
  }
}

if (initialGeo?.bbox) {
  const [wLon, sLat, eLon, nLat] = initialGeo.bbox;
  const p1 = proj(nLat, wLon);
  const p2 = proj(sLat, eLon);
  const x = Math.min(p1.x, p2.x);
  const y = Math.min(p1.y, p2.y);
  const w = Math.abs(p2.x - p1.x);
  const h = Math.abs(p2.y - p1.y);
  initialRect = { x, y, w, h };
}

const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const groups = new Map();
for (const l of languages) {
  const first = (l.sortKey || "").trim().charAt(0).toUpperCase();
  const key = letters.includes(first) ? first : "#";
  if (!groups.has(key)) groups.set(key, []);
  groups.get(key).push(l);
}

const familyGroups = new Map<string, typeof languages>();
for (const l of languages) {
  const fam = (l.family || "").trim() || "Unknown";
  if (!familyGroups.has(fam)) familyGroups.set(fam, []);
  familyGroups.get(fam)!.push(l);
}

const families = Array.from(familyGroups.keys())
  .filter((f) => f !== "Unknown")
  .sort((a, b) => a.localeCompare(b));

const regions = Array.from(
  new Set(
    languages
      .flatMap((l) => (l.regionGroup?.length ? l.regionGroup : ["Uncategorized"]))
      .map((r) => r.trim())
      .filter(Boolean)
  )
).sort((a, b) => a.localeCompare(b));
---
<BaseLayout title="LexiAtlas — Browse">
  <div class="grid">
    <section class="card">
      <div class="card-body">
        <div id="browseRoot" data-view="az">
          <details id="browseDetails" class="browse-details" open>
            <summary class="browse-summary">
              <div>
                <div style="font-weight:750">Browse languages</div>
                <div class="muted" style="font-size:0.95rem">{languages.length} language page(s)</div>
              </div>
            </summary>

            <p class="muted" style="margin:12px 0 12px">
              Select a language to view resources. This revival is community-maintained.
            </p>
            <p style="margin:0 0 12px">
              <a href="/search/">Search everything</a>
            </p>

            <div class="segmented" role="tablist" aria-label="Browse mode">
              <button type="button" class="seg-btn" data-view="az" aria-selected="true">A–Z</button>
              <button type="button" class="seg-btn" data-view="family" aria-selected="false">By family</button>
            </div>

            <div class="facet-grid" aria-label="Filters">
              <div>
                <label class="muted" for="filter">Name filter</label>
                <input id="filter" type="search" placeholder="Type to filter languages…" autocomplete="off" />
              </div>
              <div>
                <label class="muted" for="familyFilter">Family</label>
                <select id="familyFilter">
                  <option value="">Any</option>
                  {families.map((f) => (
                    <option value={f}>{f}</option>
                  ))}
                  <option value="Unknown">Unknown</option>
                </select>
              </div>
              <div>
                <label class="muted" for="regionFilter">Region</label>
                <select id="regionFilter">
                  <option value="">Any</option>
                  {regions.map((r) => (
                    <option value={r}>{r}</option>
                  ))}
                </select>
              </div>
            </div>

            <div class="muted" id="filterStatus" style="margin-top:10px" aria-live="polite"></div>

            <div class="jump-row" data-only="az">
              {letters.map((c) => (
                <a class="muted" href={`#${c}`} style="font-family:var(--mono); font-size:0.9rem">{c}</a>
              ))}
              <a class="muted" href="#other" style="font-family:var(--mono); font-size:0.9rem">#</a>
            </div>

            <div class="lang-list" style="max-height: 60vh" aria-label="Language list (A–Z)" data-list="az">
              {letters.map((c) =>
                (groups.get(c) || []).length ? (
                  <section class="lang-group" style="margin-top:12px" data-group>
                    <h2 id={c} class="muted" style="margin:10px 0 6px; font-size:0.95rem">{c}</h2>
                    <ul style="margin:0; padding:0; list-style:none">
                      {(groups.get(c) || []).map((l) => (
                        <li
                          data-title={l.sortKey}
                          data-slug={l.slug}
                          data-family={normText(l.family) || "unknown"}
                          data-region={normText((l.regionGroup?.length ? l.regionGroup : ["Uncategorized"]).join(" · "))}
                        >
                          <a href={`/language/${l.slug}/`}>{l.title}</a>
                        </li>
                      ))}
                    </ul>
                  </section>
                ) : null
              )}
              {(groups.get("#") || []).length ? (
                <section class="lang-group" style="margin-top:12px" data-group>
                  <h2 id="other" class="muted" style="margin:10px 0 6px; font-size:0.95rem">Other</h2>
                  <ul style="margin:0; padding:0; list-style:none">
                    {(groups.get("#") || []).map((l) => (
                      <li
                        data-title={l.sortKey}
                        data-slug={l.slug}
                        data-family={normText(l.family) || "unknown"}
                        data-region={normText((l.regionGroup?.length ? l.regionGroup : ["Uncategorized"]).join(" · "))}
                      >
                        <a href={`/language/${l.slug}/`}>{l.title}</a>
                      </li>
                    ))}
                  </ul>
                </section>
              ) : null}
            </div>

            <div class="lang-list" style="max-height: 60vh" aria-label="Language list (by family)" data-list="family">
              {Array.from(familyGroups.entries())
                .sort(([a], [b]) => {
                  if (a === "Unknown") return 1;
                  if (b === "Unknown") return -1;
                  return a.localeCompare(b);
                })
                .map(([fam, items]) => (
                  <section class="lang-group" style="margin-top:12px" data-group>
                    <h2 class="muted" style="margin:10px 0 6px; font-size:0.95rem">{fam}</h2>
                    <ul style="margin:0; padding:0; list-style:none">
                      {items
                        .slice()
                        .sort((a, b) => a.sortKey.localeCompare(b.sortKey) || a.title.localeCompare(b.title))
                        .map((l) => (
                          <li
                            data-title={l.sortKey}
                            data-slug={l.slug}
                            data-family={normText(l.family) || "unknown"}
                            data-region={normText((l.regionGroup?.length ? l.regionGroup : ["Uncategorized"]).join(" · "))}
                          >
                            <a href={`/language/${l.slug}/`}>{l.title}</a>
                          </li>
                        ))}
                    </ul>
                  </section>
                ))}
            </div>
          </details>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="prose">
        <h1 style="margin-top:0">Welcome</h1>
        <p>
          LexiAtlas is a community-maintained index of resources for ancient and historical languages.
          The goal is simple: make it easier to find grammars, dictionaries, texts, and learning material—then keep it current.
        </p>
        <p>
          Learning a “dead” language is a living skill: it’s a way to read primary sources, understand how languages work,
          and connect with communities of readers across time.
        </p>
        <p class="muted">
          Start by choosing a language on the left, or try <a href="/search/">Search</a>.
          If you notice a broken/outdated link, use <a href="/contribute/">Contribute</a>.
        </p>

        <div class="welcome-panels" aria-label="Highlights">
          {featuredItems.length ? (
            <section class="mini-card" aria-label="Featured language">
              <div class="mini-head">
                <div class="mini-title">Featured language</div>
              </div>
              <div class="mini-body">
                <div style="display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap">
                  <div style="flex: 1 1 280px">
                    <div style="font-weight:750; font-size:1.05rem">
                      <a id="featuredLink" href={`/language/${featuredItems[0].slug}/`}>{featuredItems[0].title}</a>
                    </div>
                    <p id="featuredBlurb" class="muted" style="margin:6px 0 0">{featuredItems[0].blurb}</p>
                    <div id="featuredChips" class="facts-row" style="margin-top:10px">
                      {featuredItems[0].family ? <span class="chip">Family: {featuredItems[0].family}</span> : null}
                      {featuredItems[0].branch ? <span class="chip">Branch: {featuredItems[0].branch}</span> : null}
                    </div>
                  </div>
                  <div style="flex: 0 1 260px; min-width: 220px">
                    <figure class="map" aria-label="Featured language location">
                      <svg
                        viewBox={`0 0 ${FEATURE_W} ${FEATURE_H}`}
                        role="img"
                        aria-label="Featured language location"
                        preserveAspectRatio="xMidYMid meet"
                      >
                        <rect x="0" y="0" width={FEATURE_W} height={FEATURE_H} class="map-bg" />
                        {landPath ? <path d={landPath} class="map-land" /> : null}
                        {[-120, -60, 0, 60, 120].map((lon) => {
                          const p = projection([lon, 0]);
                          const x = p?.[0] ?? lon + 180;
                          return <line x1={x} y1="0" x2={x} y2={FEATURE_H} class="map-grid" />;
                        })}
                        {[-60, -30, 0, 30, 60].map((lat) => {
                          const p = projection([0, lat]);
                          const y = p?.[1] ?? 90 - lat;
                          return <line x1="0" y1={y} x2={FEATURE_W} y2={y} class="map-grid" />;
                        })}

                        <rect
                          data-featured-rect
                          rx="3"
                          class="map-region"
                          x={initialRect?.x}
                          y={initialRect?.y}
                          width={initialRect?.w}
                          height={initialRect?.h}
                          style={initialRect ? "" : "display:none"}
                        />
                        <ellipse
                          data-featured-ellipse
                          class="map-region"
                          cx={initialEllipse?.cx}
                          cy={initialEllipse?.cy}
                          rx={initialEllipse?.rx}
                          ry={initialEllipse?.ry}
                          style={initialEllipse ? "" : "display:none"}
                        />
                        <circle
                          data-featured-dot
                          r="2.2"
                          class="map-dot"
                          cx={initialDot?.cx}
                          cy={initialDot?.cy}
                          style={initialDot ? "" : "display:none"}
                        />
                      </svg>
                    </figure>
                  </div>
                </div>
              </div>
            </section>
          ) : null}

          <section class="mini-card" aria-label="What’s new">
            <div class="mini-head">
              <div class="mini-title">What’s new</div>
            </div>
            <div class="mini-body">
              {(WHATS_NEW?.length ?? 0) > 0 ? (
                <ul style="margin: 0; padding-left: 18px">
                  {WHATS_NEW.slice(0, 4).map((i) => (
                    <li style="margin: 6px 0">
                      {i.href ? <a href={i.href}>{i.text}</a> : i.text}
                      {i.date ? <span class="muted"> · {i.date}</span> : null}
                    </li>
                  ))}
                </ul>
              ) : (
                <p class="muted" style="margin:0">No recent updates yet.</p>
              )}
            </div>
          </section>
        </div>

        <hr />
        <p class="muted">Imported language pages: {languages.length}.</p>
      </div>
    </section>
  </div>

  <script id="featuredData" type="application/json" set:html={featuredJson}></script>

  <script is:inline>
    // Featured language: rotate by day on the client (works on static deploys).
    try {
      const dataEl = document.getElementById("featuredData");
      const items = dataEl ? JSON.parse(dataEl.textContent || "[]") : [];
      if (Array.isArray(items) && items.length) {
        const day = Math.floor(Date.now() / 86400000);
        const idx = ((day % items.length) + items.length) % items.length;
        const it = items[idx] || items[0];

        const link = document.getElementById("featuredLink");
        if (link && it?.slug && it?.title) {
          link.textContent = String(it.title);
          link.setAttribute("href", `/language/${encodeURIComponent(String(it.slug))}/`);
        }

        const blurb = document.getElementById("featuredBlurb");
        if (blurb) {
          const b = String(it?.blurb || "").trim();
          if (b) {
            blurb.textContent = b;
            blurb.style.display = "";
          } else {
            blurb.textContent = "";
            blurb.style.display = "none";
          }
        }

        const chips = document.getElementById("featuredChips");
        if (chips) {
          chips.textContent = "";
          const fam = String(it?.family || "").trim();
          const br = String(it?.branch || "").trim();
          function addChip(text) {
            const s = document.createElement("span");
            s.className = "chip";
            s.textContent = text;
            chips.appendChild(s);
          }
          if (fam) addChip(`Family: ${fam}`);
          if (br) addChip(`Branch: ${br}`);
        }

        const W = 360;
        const H = 180;
        function clamp(n, lo, hi) {
          return Math.max(lo, Math.min(hi, n));
        }
        function normLon(lon) {
          return ((lon + 180) % 360 + 360) % 360 - 180;
        }
        function proj(lat, lon) {
          const clat = clamp(Number(lat), -85, 85);
          const clon = normLon(Number(lon));
          const x = ((clon + 180) / 360) * W;
          const y = ((90 - clat) / 180) * H;
          return { x, y, clat, clon };
        }
        function kmToLatDeg(km) {
          return Number(km) / 111;
        }
        function kmToLonDegAtLat(km, lat) {
          const r = (Math.PI / 180) * Number(lat);
          const denom = 111 * Math.max(0.2, Math.cos(r));
          return Number(km) / denom;
        }

        const rect = document.querySelector("[data-featured-rect]");
        const ell = document.querySelector("[data-featured-ellipse]");
        const dot = document.querySelector("[data-featured-dot]");

        function hide(el) {
          if (!el) return;
          el.style.display = "none";
        }
        function show(el) {
          if (!el) return;
          el.style.display = "";
        }

        hide(rect);
        hide(ell);
        hide(dot);

        const geo = it?.geo || {};
        if (geo?.bbox && Array.isArray(geo.bbox) && geo.bbox.length === 4 && rect) {
          const wLon = geo.bbox[0],
            sLat = geo.bbox[1],
            eLon = geo.bbox[2],
            nLat = geo.bbox[3];
          const p1 = proj(nLat, wLon);
          const p2 = proj(sLat, eLon);
          const x = Math.min(p1.x, p2.x);
          const y = Math.min(p1.y, p2.y);
          const w = Math.abs(p2.x - p1.x);
          const h = Math.abs(p2.y - p1.y);
          rect.setAttribute("x", String(x));
          rect.setAttribute("y", String(y));
          rect.setAttribute("width", String(w));
          rect.setAttribute("height", String(h));
          show(rect);
        }

        if (geo?.center && typeof geo.center === "object" && dot) {
          const p = proj(geo.center.lat, geo.center.lon);
          dot.setAttribute("cx", String(p.x));
          dot.setAttribute("cy", String(p.y));
          show(dot);

          const km = Number(geo.radiusKm || 0);
          if (km > 0 && ell) {
            const ry = kmToLatDeg(km);
            const rx = kmToLonDegAtLat(km, p.clat);
            const px1 = proj(p.clat + ry, p.clon);
            const px2 = proj(p.clat, p.clon + rx);
            ell.setAttribute("cx", String(p.x));
            ell.setAttribute("cy", String(p.y));
            ell.setAttribute("rx", String(Math.abs(px2.x - p.x)));
            ell.setAttribute("ry", String(Math.abs(px1.y - p.y)));
            show(ell);
          }
        }
      }
    } catch (_) {}

    // Mobile: collapse the browse panel by default.
    try {
      const details = document.getElementById("browseDetails");
      if (details && window.matchMedia("(max-width: 900px)").matches) {
        details.removeAttribute("open");
      }
    } catch (_) {}

    // View toggle (A–Z vs By family)
    const browseRoot = document.getElementById("browseRoot");
    const segBtns = Array.from(document.querySelectorAll(".seg-btn"));
    function setView(view) {
      if (!browseRoot) return;
      browseRoot.setAttribute("data-view", view);
      for (const b of segBtns) {
        const v = b.getAttribute("data-view");
        const sel = v === view;
        b.setAttribute("aria-selected", sel ? "true" : "false");
      }
    }
    for (const b of segBtns) {
      b.addEventListener("click", () => setView(b.getAttribute("data-view") || "az"));
    }

    const input = document.getElementById("filter");
    const family = document.getElementById("familyFilter");
    const region = document.getElementById("regionFilter");
    const status = document.getElementById("filterStatus");
    const items = Array.from(document.querySelectorAll("[data-title]"));
    const groups = Array.from(document.querySelectorAll("[data-group]"));
    const totalUnique = new Set(items.map((li) => li.getAttribute("data-slug") || "")).size;

    function update() {
      const q = (input.value || "").trim().toLowerCase();
      const fam = ((family && family.value) || "").trim().toLowerCase();
      const reg = ((region && region.value) || "").trim().toLowerCase();
      const shownUnique = new Set();
      for (const li of items) {
        const t = li.getAttribute("data-title") || "";
        const lf = li.getAttribute("data-family") || "";
        const lr = li.getAttribute("data-region") || "";
        const okQ = !q || t.includes(q);
        const okF = !fam || lf === fam;
        const okR = !reg || lr.includes(reg);
        const ok = okQ && okF && okR;
        li.style.display = ok ? "" : "none";
        if (ok) shownUnique.add(li.getAttribute("data-slug") || "");
      }
      for (const g of groups) {
        const any = Array.from(g.querySelectorAll("[data-title]")).some((li) => li.style.display !== "none");
        g.style.display = any ? "" : "none";
      }
      status.textContent = q || fam || reg ? `${shownUnique.size} match(es).` : `${totalUnique} language(s).`;
    }
    input.addEventListener("input", () => {
      window.clearTimeout(window.__lexicityFilterT);
      window.__lexicityFilterT = window.setTimeout(update, 80);
    });
    if (family) family.addEventListener("change", update);
    if (region) region.addEventListener("change", update);
    update();
  </script>
</BaseLayout>

